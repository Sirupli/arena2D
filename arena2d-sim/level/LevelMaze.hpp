#ifndef LEVELMAZE_H
#define LEVELMAZE_H

#include "Level.hpp"
#include "Wanderers.hpp"

#define LEVEL_RANDOM_GOAL_SPAWN_AREA_BLOCK_SIZE 0.1 // maximum size of block when creating quad tree of goal spawn area

class LevelMaze : public Level
{
public:

	/* constructor
	 */
	LevelMaze(const LevelDef & d, bool dynamic = false) : Level(d), _dynamic(dynamic), wanderers(d){}

	/* destructor
	 */
	~LevelMaze(){}

	// copy the functions from levelRandom.hpp to have a try at first
	/* reset
	 */
	void reset(bool robot_position_reset) override;

	/* update
	 */
	void update() override{
		wanderers.update();
	}

	/* render spawn area
	 * overriding to visualize spawn area for dynamic obstacles
	 */
	void renderGoalSpawn() override;

	/* provide the agent with additional data generated by level
	 * @param data any values pushed into this vector will be passed to the agent as additional observations
	 */
	void getAgentData(std::vector<float> & data) override{
		wanderers.getWandererData(data);
	}

	/* get level specific reward, called after every complete simulation step (not on every step iteration)
	 * use this function to implement custom reward functions that depend on additional metrics in the level
	 * @return agent reward 
	 */
	float getReward() override;

	/* check if robot had contact with a human
 	 * @return true if contact with human and false otherwise
	 */
	bool checkHumanContact(b2Fixture * other_fixture) override{
		return wanderers.checkHumanContact(other_fixture);
	}

	// from here all the functions are from old version
	//b2Body* generateRandomBody(float min_radius, float max_radius, zRect * aabb);
        b2Body* generateRandomWalls11(int index, zRect * aabb);
   	b2Body* generateRandomWalls22(int index, int numm, zRect * aabb);
   	
   	void getClosestHumanDistance(float & l2_h, float & angle_h)

	/* get the closest human 
	 * @return Box2D fixture of the goal or NULL if goal does not exist
	 */
	//b2Fixture* getClosestHuman(){return (_human == NULL) ? NULL : _human->GetFixtureList();}

	/* get the closest human position
	 * @return current position of the goal or (0,0) if goal does not exist
	 */
	//b2Vec2 getClosestHumanPosition(){return (_human ==  NULL) ? b2Vec2(0,0) : _human->GetTransform().p;}
	
	/* get the current closest to robot human of all humans
	 * @param relative distance and angle to the robot of the closest human 
	 */

        void getClosestHumanDistanceAngle(float & l2_h, float & angle_h){
             if(_dynamic){
                   wanderers.getClosestHumanDistance(l2_h,angle_h);
             }else{
                  l2_h=2*_SETTINGS->stage.level_size;
             
             }
        }



private:
	/* free wanderers and clear list
	 */
	void freeWanderers();

	std::vector<float> _closestDistance; //current distances from robot to closest wanderers
	std::vector<float> _closestDistance_old; //last closest distances from robot to wanderers

	/* if set to true, create dynamic obstacles (wanderers) in addition to static */
	bool _dynamic;

	/* list that stores all wanderers for dynamic level */
	std::list<Wanderers*> _wanderers;

	/* handles all wanderers for dynamic level */
	Wanderers wanderers;

	/* body of the closest humans */
	//Wanderers * _human;

	/* spawn area for dynamic obstacles */
	RectSpawn _dynamicSpawn;

};

#endif
